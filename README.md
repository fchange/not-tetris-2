# 物理俄罗斯方块 (Matter.js)

一个基于 Matter.js 构建的 2D 物理俄罗斯方块变种游戏。本项目旨在探索在经典方块堆叠游戏中融合真实的物理模拟。

## 概述

与传统基于网格的移动和即时消除不同，本游戏利用 Matter.js 物理引擎模拟下落方块的重力、碰撞、摩擦和平衡。玩家通过施加扭矩来控制方块，从而实现更自然、更不可预测的堆叠行为。消除是基于预定义的水平区域内的面积占比，并采用物理切割机制完成。

## 核心游戏机制

*   **2D 物理引擎:** 由 `Matter.js` 驱动。
*   **真实模拟:** 方块 (body) 受重力影响，会发生真实碰撞，表现出摩擦力，并且需要保持物理平衡。
*   **创新控制:** 左、右方向键对方块施加扭矩，使其根据自身形状和当前朝向自然旋转。
*   **基于物理的堆叠:** 方块遵循物理定律进行堆叠和稳定，可能会形成不稳定的结构。

## 区域与消除机制

*   **检测带:** 游戏区域被划分为 `N` 个固定高度的水平检测带。
*   **基于面积的触发:** 当任意一个检测带内的物理对象占据其总面积的 90% 或以上时，该检测带将被标记为待消除。
*   **物理切割消除:**
    *   消除过程涉及"切割"与被清空区域相交的物体。
    *   原始物体将从物理世界中移除。
    *   创建新的、更小的物体，代表原始物体在被清空区域上方和下方的部分，并保留其物理属性。
*   **静止检测:** 只有当模拟中**所有**动态物体完全静止 (`isSleeping`) 后，才会触发区域占用检查和后续的消除判定。

## 得分系统

采用多维度积分体系奖励技巧性操作：

*   **基础得分:** 每消除一个检测带获得 `基础分 * 当前难度系数`。
*   **连击奖励:** 在单次"静止-检测-消除"循环中消除多个检测带，会触发基于斐波那契数列的倍率奖励 (1x, 1x, 2x, 3x, 5x, 8x...)。
*   **风险奖励:** 在游戏区域顶部成功放置并稳定方块会获得基于高度的得分加成。

## 难度递进

*   **难度增加:** 难度系数会随着游戏进程（例如基于时间或放置的方块数量）逐渐增加。
*   **方块加速:** 新方块的初始下落速度或生成频率与难度系数成正比。
*   **游戏结束:** 如果任何方块的任何部分接触到游戏区域指定的顶部边界，则游戏结束。

## 高级特性 (未来实现)

这些特性计划在后续开发阶段实现，但属于整体概念的一部分：

*   **环境干扰:** 随机事件，如暂时的重力变化或导致堆叠方块晃动的"地震"。
*   **物理碎片效果:** 消除方块时，通过视觉增强效果展示方块碎裂或产生小的碎片粒子。
*   **可选粘滞流体模式:** 在游戏区域底部（或整体）引入模拟流体环境，增加粘滞阻力，使精确堆叠更具挑战性。

## 实现步骤

1.  **项目设置:**
    *   创建 `index.html`。
    *   设置用于渲染的 canvas 元素。
    *   引入 `Matter.js` 库。
2.  **初始化物理世界:**
    *   创建 `Matter.Engine`, `Matter.Render`, 和 `Matter.Runner`。
    *   定义世界边界（地面、墙壁、顶部边界）。
    *   设置重力。
3.  **方块生成:**
    *   使用 `Matter.Bodies` 工厂函数（矩形、多边形）或 `Matter.Composite` 定义俄罗斯方块形状。考虑使用复合体 (compound bodies) 来创建复杂形状。
    *   实现一个函数，用于随机选择并在游戏区域上方生成新方块。
4.  **控制系统:**
    *   添加键盘事件监听器 (例如 `keydown`)。
    *   当按下左/右方向键时，对当前活动方块施加扭矩（使用 `Matter.Body.applyForce` 并设置偏移量，或使用 `Matter.Body.setAngularVelocity`）。
    *   (可选) 实现"快速下落"机制（例如，按下方向键时增加下落速度）。
5.  **碰撞与堆叠:**
    *   `Matter.js` 自动处理碰撞检测和响应。
    *   如果特定游戏逻辑需要，可以监控碰撞事件（尽管堆叠是引擎内置行为）。
6.  **静止检测:**
    *   在游戏循环中或使用 `Matter.Events.on(engine, 'afterUpdate', ...)` 检查所有相关的动态物体是否处于休眠状态 (`body.isSleeping === true`)。可以使用计数器或标志来管理此状态。
7.  **检测带:**
    *   定义每个水平检测带的垂直边界。
    *   当满足"所有物体静止"条件时：
        *   遍历每个检测带。
        *   对于每个检测带，遍历所有相关的物体。
        *   计算每个物体与该检测带的相交面积（使用几何运算或顶点检查）。
        *   将相交面积求和，并与检测带的总面积（宽度 * 检测带高度）进行比较。
8.  **消除逻辑:**
    *   如果一个检测带的占用率 >= 90%:
        *   识别所有与该检测带相交的物体。
        *   对于每个相交的物体：
            *   计算切割后新碎块（上方和下方）的几何形状。可能需要 `Matter.Vertices.chamfer`、`Matter.Vertices.hull` 或手动顶点计算，具体取决于复杂性。
            *   移除原始物体 (`Matter.World.remove`)。
            *   创建并添加新的物体 (`Matter.Bodies.fromVertices`, `Matter.World.add`)，赋予适当的属性（继承或重新计算质量、摩擦力、弹性系数）。
        *   处理可能产生的小碎片或边缘情况。
9.  **得分系统:**
    *   跟踪每个周期消除的检测带数量，用于计算连击。
    *   实现斐波那契倍率。
    *   根据参与消除的稳定方块的 `y` 坐标计算高度奖励。
    *   更新并显示得分。
10. **难度递进:**
    *   实现计时器或方块计数器以增加 `difficulty_multiplier`。
    *   根据难度系数调整方块生成速度/初始速度。
11. **游戏结束条件:**
    *   使用 `Matter.Events.on(engine, 'collisionStart', ...)` 或在更新循环中检查物体位置，以检测与顶部边界的接触。
    *   触发游戏结束状态（停止生成方块，显示最终得分）。
12. **UI/UX:**
    *   显示得分、当前难度级别、连击状态。
    *   (可选) 显示下一个方块。
    *   (可选) 可视化渲染检测带（用于调试或效果）。
13. **高级特性 (核心功能完成后):**
    *   实现随机重力变化 (`engine.world.gravity.y`)。
    *   在消除时添加视觉粒子效果。
    *   如果选择实现该特性，则模拟流体动力学。

## 依赖项

*   [Matter.js](https://brm.io/matter-js/)

## 运行项目

1.  确保你的项目目录中包含 `Matter.js` 库文件（例如 `matter.js` 或 `matter.min.js`），或者通过 CDN 链接引入。
2.  在支持现代 JavaScript 和 Canvas API 的网页浏览器中打开 `index.html` 文件。

## 如何游戏 (示例)

*   **左方向键:** 施加逆时针扭矩。
*   **右方向键:** 施加顺时针扭矩。
*   **(可选) 下方向键:** 加快下落速度。 